# Понятия и определения

*   **Продукт** \- это программное обеспечение или система, разработанная и поддерживаемая ИТ-подразделением, предназначенная для удовлетворения бизнес-потребностей организации.
*   **Сервис** \- это услуга, предоставляемая ИТ-подразделением, которая может включать в себя поддержку, обслуживание, обновление и управление ИТ-ресурсами.
*   **Инфраструктурная единица** - это отдельный компонент ИТ-инфраструктуры, такой как сервер, сетевое оборудование или программное обеспечение, который играет ключевую роль в поддержании операций организации.
https://w.forfun.com/fetch/da/daf8eb568fea522f6701fb9c66378cdc.jpeg
  

  

  

1. шаблон/чеклист
    1. описания продукта
    2. задача разработчика
        1. типы задач
    3. задача аналитика
    4. инфраструктурной единицы
    5. сервиса
2. список сервисов и продуктов

  

  

Описание продукта, пример

1. **Введение**: Этот раздел представляет продукт, объясняет его назначение, основные кейсы использования, описывает основные функции .
2. **Установка и настройка**: Здесь подробно описывается процесс установки и настройки программного обеспечения.
3. **Руководство пользователя**: В этом разделе приводятся инструкции по использованию продукта, включая пошаговые руководства и советы.
4. **Справочник API**: Если продукт имеет API, этот раздел содержит детальное описание всех доступных методов и параметров.
5. **Зависимости**: Если продукт имеет зависимости или от него зависят другие продукты.
6. **Часто задаваемые вопросы (FAQ)**: Этот раздел содержит ответы на наиболее часто задаваемые вопросы пользователей.
7. **Решение проблем**: Здесь описываются типичные проблемы, которые могут возникнуть при использовании продукта, и предлагаются способы их решения.
8. **Приложения**: В этом разделе могут быть представлены дополнительные материалы, такие как технические спецификации, графики и таблицы.
9. **Развернутые копии продукта:** Где и как развернут продукт, особенности

# Список сервисов и продуктов

  

*   Собственные продукты:
    *   sp\_shop
    *   sp\_store
    *   mcenter
    *   patcher
    *   dbconfigExplorer
    *   proxypatcher
    *   spmacro language
    *   mailexch
    *   printserver
    *   База Заявок
*   Сервисы:
    *   proxypatcher
        *   spquery
        *   scheduler
        *   printserver
    *   обмен данными
    *   регламентные задания/процедуры

  

*       *   ЭДО
    *   1С
        *   правила обмена
        *   3ex
*       *   службы баз данных:
        *   mcenter
        *   store
        *   shop

  

*   Инфраструктура:
    *   собственные сервера
    *   облачные сервера
    *   файловое хранилище
    *   Терминальные серверы

  

инструмент документирования

требования

*       *       *   версионность и git
        *   поддержка markdown
        *   доступность с web
        *   ссылки на отдельные страницы и разделы (+публичные ссылки)
        *   встроенный поиск

  

*   регламенты обновления документации

# Шаблоны документов

1. шаблон/чеклист
    1. продукт
    2. сервис
    3. задача , разработка продукта
        1. типы задач
    4. задача, развитие инфраструктуры
        1. типы задач
    5. задача аналитика
    6. инфраструктурная единица

  

  

Описание продукта, пример

1. **Введение**: Этот раздел представляет продукт, объясняет его назначение, основные кейсы использования, описывает основные функции .
2. **Установка и настройка**: Здесь подробно описывается процесс установки и настройки программного обеспечения.
3. **Руководство пользователя**: В этом разделе приводятся инструкции по использованию продукта, включая пошаговые руководства и советы.
4. **Справочник API**: Если продукт имеет API, этот раздел содержит детальное описание всех доступных методов и параметров.
5. **Внутренняя архитектура продукта**, **Зависимости** описаны основные модули, зависимости, как это работает изнутри.
6. **Часто задаваемые вопросы (FAQ)**: Этот раздел содержит ответы на наиболее часто задаваемые вопросы пользователей.
7. **Решение проблем**: Здесь описываются типичные проблемы, которые могут возникнуть при использовании продукта, и предлагаются способы их решения.
8. **Приложения**: В этом разделе могут быть представлены дополнительные материалы, такие как технические спецификации, графики и таблицы.
9. **Развернутые копии продукта:** Где и как развернут продукт, особенности
10. Changelog

  

Описание сервиса

  

1. **Введение**: Этот раздел представляет сервис, объясняет его назначение, основные кейсы использования, описывает основные функции.
2. **Архитектура сервиса**, **Зависимости** описаны основные модули, зависимости, как это работает изнутри.
3. **Установка и настройка**: Здесь подробно описывается процесс установки и настройки сервиса.
4. **Руководство пользователя**: В этом разделе приводятся инструкции по использованию сервиса, включая пошаговые руководства и советы.
5. **Справочник API**: Если сервис имеет API, этот раздел содержит детальное описание всех доступных методов и параметров.
6. **Часто задаваемые вопросы (FAQ)**: Этот раздел содержит ответы на наиболее часто задаваемые вопросы пользователей.
7. **Решение проблем**: Здесь описываются типичные проблемы, которые могут возникнуть при использовании сервиса, и предлагаются способы их решения.
8. **Приложения**: В этом разделе могут быть представлены дополнительные материалы, такие как технические спецификации, графики и таблицы.
9. **Развернутые копии сервиса**: Где и как развернут сервис, особенности.
10. Changelog

# Типы задач

```plain
первый тип манипуляции с отчетами внутри программы и добавление, удаление и переработка функционала
второй тип выгрузка документы образовалась в текущей ситуации когда были зашифрованы все базы данных и они подлежат восстановлению
перенести события из баз данных
сделать классификацию отчетов
доработать классификацию отчетов
```

Задачи

*   Задачи развития
    *   Разработка нового инструмента: Private ([https://app.clickup.com/t/85zt1df61](https://app.clickup.com/t/85zt1df61)) Private ([https://app.clickup.com/t/8692r6tzu](https://app.clickup.com/t/8692r6tzu))
    *   Доработка инструмента, новый функционал:Private ([https://app.clickup.com/t/344wczg](https://app.clickup.com/t/344wczg)) Private ([https://app.clickup.com/t/8692nzec5](https://app.clickup.com/t/8692nzec5)) Private ([https://app.clickup.com/t/8692pjcx3](https://app.clickup.com/t/8692pjcx3)) Private ([https://app.clickup.com/t/85ztcgc53](https://app.clickup.com/t/85ztcgc53))
    *   _Анализ бизнес процессов и разработка решения по его автоматизации_

  

*   Поддержка
    *   Ошибки: Private ([https://app.clickup.com/t/8692u5658](https://app.clickup.com/t/8692u5658)) Private ([https://app.clickup.com/t/86931p4nj](https://app.clickup.com/t/86931p4nj)) Private ([https://app.clickup.com/t/8692wpu88](https://app.clickup.com/t/8692wpu88))
    *   Настройка и администрирование Private ([https://app.clickup.com/t/8692u0vgu](https://app.clickup.com/t/8692u0vgu))

  

*   Задачи инфраструктурные
    *   Администрирование инфраструктурных единиц
    *   Оптимизация использования серверного, сетевого оборудования
    *   Реинжиниринг ПО, запросов
    *   Внедрение новых инфраструктурных сервисов
    *   Меры направленные на защиту данных

На основе этого списка добавил в регламент описания выполненных работ примеры описания конкретных типов задач после выполнения

# Задачи развития



# Разработка нового инструмента



# sadads

asdasdasd

as

# План

*   Документ по командам в кликапе(доработать читаемость)√
*   Типы задач - до заполнить**√**
*   **Проанализировать задачи за три месяца перед октябрем и соотнести их с разделами в типах задач√↓§→↔↑↨§↓↑**
*   доделать регламент описания выполненных работ**√**
*   Погуглить , взять удачный пример содержания для описания языка **spmacro**. подобрать похожий по функционалу**√(посмотреть разделы и чему посвящаются в языке phpили другие интерпретируемые языки которые могут к нам относиться и лучше изучить документацию в фаворитах)**
*   Карточки задачи(что удалось найти)
*   Private ([https://app.clickup.com/t/86932yp1y](https://app.clickup.com/t/86932yp1y))
*   Private ([https://app.clickup.com/t/86932yp3q](https://app.clickup.com/t/86932yp3q))

# ЧатГПТ spmacro

PHP ➝ html

  

SPMACRO ➝ SQL

  

[{{ mustache }}](https://mustache.github.io/#demo)

  

Интерпретируемый язык. Похож на шаблонизотор, text-processing engine

  

Язык называется spmacro. Изначально он был предназначен для написания шаблонов SQL которые выполнялись для извлечения данных из БД. Однако со временем очень развился.

В нем появились цикл, переменный, большой набор встроенных функций, возможность использовать OLE, winhttp.

  

Понял, что вам нужно создать структурированную документацию по языку программирования spmacro для молодых разработчиков. Ниже представлена структура документации с разделами, которые могут быть полезными для начинающих разработчиков:

  

# Документация по языку spmacro

  

## Введение

  

*   Что такое spmacro?
*   История развития языка
*   Цели и область применения

  

## Установка и настройка

  

*   Как установить среду разработки для spmacro?
*   Настройка среды разработки
*   Создание первого проекта
*   добавить ссылки какие клиентские приложения\*

  

## Основы языка

  

*   Синтаксис и структура кода
*   Объявление переменных(Операторы присваивания не писать в оглавлении)
*   Встроенные типы данных
*   Ввод и вывод данных

  

## Операторы и выражения

  

*   Арифметические операторы
*   Логические операторы
*   Условные операторы (if, else, switch)
*   Циклы (for, while, do-while)

  

## Функции и процедуры

  

*   Определение и вызов функций
*   Передача аргументов в функции
*   Возвращаемые значения
*   Встроенные функции и библиотеки

  

## Работа с базой данных

  

*   Подключение к базе данных
*   Выполнение SQL-запросов
*   Обработка результатов запросов
*   Транзакции

  

## Расширенные возможности

  

*   Использование OLE
*   Взаимодействие с winhttp
*   Работа с файлами
*   Работа с сетью
*   Работа с XML и JSON

  

## Примеры и практика

  

*   Примеры кода для различных задач
*   Учебные задания и проекты для практики

  

## Лучшие практики и советы

  

*   Стиль кодирования
*   Оптимизация производительности
*   Отладка и тестирование
*   Обработка ошибок

  

## Дополнительные ресурсы

  

*   Ссылки на официальную документацию
*   Книги и учебники
*   Форумы и сообщества для обсуждения и поддержки

  

## Заключение

  

*   Перспективы развития языка spmacro
*   Спасибо за использование языка и документации

  

Это лишь предложенная структура, и вы можете дополнить ее или изменить в соответствии с особенностями и потребностями вашего языка spmacro и вашей целевой аудитории. По мере поступления информации о языке, я могу помочь вам заполнять каждый из разделов более конкретным содержанием.

# Описание основных команд среды разработки “sp macro”

  

#### 1.Работа с формами

**#form\_get\_name**

Прочитать имя формы, открытого отчета, результат в переменной form\_name

#form\_get\_name

#msg fname=\[form\_name\]

Пример использования:

**#timer\_add**

Создание таймера, в контексте SPForm

#timer\_add id,\[interval\_mls=1000,count=0,proc\_name\]

по истечению времени таймера будет выполнена процедура proc\_name

если proc\_name не указан будет запущен обработчки формы

обработчика event.on\_timer.\[id\]

interval\_mls - количество миллисекунд до запуска обработчика

count - количество циклов таймера

Пример использования:

**#form\_set**

Установка значения свойства объекта текущей формы

#form\_set property\_name=value

property\_name - свойство объекта формы

value - значение

#form\_set caption=caption формы

Пример использования:

**#form\_close**

Принудительное закрытие формы, срабатывает обработчик #proc report\_close

В report\_close можно отменить закрытие формы

#s report\_close\_cancel=1

Пример использования:

**#form\_update**

#form\_update param

Инициирует вызов процедуры обновления формы,

вызывает обработчик spmacro event.form\_update

в связанном с формой модуле

передает параметр param.

Параметр не обязательный

Пример использования:

**#form\_activate**

#form\_activate - активирует форму связанную с текущим выполняемым модулем.

Форма выходит на передний план, если была свернута - восстанавливается.

Фокус ввода передается на форму.

Пример использования:

**#set\_form\_caption**

#set\_form\_caption CAPTION

задает заголовок окну формы, связанной с текущим контекстом

Пример использования:

#set\_form\_caption  Форма документа

**#form\_text\_rect**

#form\_text\_rect TEXT

возвращает в переменной form\_text\_rect размер текста ширина,высота

\=>

40,12

Пример использования:

**#form\_show #form\_bringtofront**

#form\_show - выводит текущее окно формы поверх других

#form\_bringtofront - аналогично #form\_show дополнительно передает окну фокус

**#form\_get\_hwnd**

Позволяет получить параметр дескриптора

Пример использования:

  

#### 2.ActionManager для работы с действиями

**#start\_action**

Запуск действия, определенного во вкладке "Действия"

#start\_action action\_name

action\_name - полное наименование действия.

  

#### 3\. Работа с exe программы

**#application\_path\_get**

#application\_path\_get \[var\_name\]

получает путь из которого запущено приложение в переменную

application\_path\_get либо в указанную var\_name

Пример использования:

#application\_path\_get

#msg \[application\_path\_get\]

#application\_path\_get path

#msg \[path\]

**#application\_exit**

Выйти из программы

Пример использования:

**#application\_params**

Получить аргумент с которым была запущена программа

передача параметров: -PARAM=VAL PARAM=VAL PARAM:VAL

patcher.exe -debug=1

Пример использования:

#application\_params debug

;\[debug\]=1

Возвращает значение первого параметра, который встретился в аргументах.

**#exe\_name**

#exe\_name

получает полный имя выполняемого файла в переменную

exe\_name

Пример использования:

#exe\_name

#msg \[exe\_name\] = c:\\sp\\patcher.exe

**#exe\_path**

#exe\_path

получает полный путь выполняемого файла в переменную

exe\_path

Пример использования:

#exe\_path

#msg \[exe\_path\] = c:\\sp\\

#exe\_version

Заполняет переменную **exe\_version** версию сборки

Пример использования:

  

  

#### 4\. Работы с контрольной секцией

**#case & #then**

Конструкция

#case {log expression} #then {command or string}

\- условия в формате команды #if

Допускается расширение команды через #>

Пример использования:

#case 1 #then #s var=One

#>#msg \[var\]

**#ifdef**

Проверка что переменная определена

Пример использования:

#ifdef var\_name

..определена

#else

#endif

#ifdef !var\_name

..не определена

#else

#endif

**#goto #met**

Оператор перехода выполнения

Используется вместе c #met

Разрешены переходы внутри одной процедуры.

#met {ИмяМетки}

#goto {ИмяМетки}

Пример использования:

#met REPEAT

...

...

#goto REPEAT

Пример использования:

#goto EXIT

...

...

#met EXIT

условный периход

#goto met\_name ?

Пример использования:

#goto met\_name $asd=1

**#if #else #elseif #endif**

Конструкция условного выполнения

#if

#elseif {log expression}

#elseif {log expression}

#else

#endif

Пример использования:

**#cdata\_start #cdata\_end**

Определяет блок строк, которые игнорирует интерпретатор

Пример использования:

#cdata\_start

...

#cdata\_end

Строки внутри блока будут добавлены в текущий out

**#control\_section**

Реализует логику контрольной секции.

Привязана к parser\_instance, при завершение парсера уничтожается.

#control\_section section\_name,cmd\_str

| section\_name | уникальное имя в рамках |
| ---| --- |
| cmd\_str | команда для запуска в случае существовании секции |

Пример использования:

#control\_section once, #goto skip

#se once=1

#met skip

Пример использования

#proc once

#control\_section once, #exitproc

...

#endproc

**#control\_section\_proc**

Аналогично #control\_section

 только уничтожается при завершении процедуры в которой создана

**#control\_section\_release**

Уничтожает ранее созданную контрольную секцию

Пример использования:

#control\_section\_release section\_name

  

  

#### 5.Работа с gui диалогами

**#save\_file\_dlg**

Запускает диалог Windows выбор файла для записи. Создает при необходимости директории.

Пример использования:

#save\_file\_dlg filename\_var,extension\_list,mode

#s file=c:\\tmp\\test.txt

#save\_file\_dlg file,\*.txt|\*.xtx,must\_exists

#if $save\_file\_dlg\_ok

#msg file=\[file\]

#endif

**#select\_file**

Запускает диалог Windows выбор файла. Создает при необходимости директории.

Пример использования:

#save\_file\_dlg filename\_var,extension\_list,mode

#s file=c:\\tmp\\test.txt

#select\_file file,\*.txt|\*.spm,must\_exists

#if $select\_file\_ok

#msg file=\[file\]

#endif

**#input\_date**

Пример использования:

#input\_date date\_var Заголовок

#v date=2021-09-21

#input\_date date введи дату

#if $input\_date\_ok

#msg \[date\]

#endif

**#input\_password**

#input\_password pass\_var Заголовок

переменные заполняются после завершения диалога:

#input\_password\_ok - результат 0/1

#input\_password\_clipboard - значение вставлено из буфера обмена

#input\_password\_ticks - количество миллисекунд от ввода первого и последнего символа

Пример использования:

#v pass=1234

#input\_password pass введи пароль

#if $input\_password \_ok

#msg \[pass\]

#endif

**#input\_period**

 #input\_period period\_from,period\_to,Заголовок

Пример использования:

#input\_period from,to,задай период

#if $input\_period\_ok

#msg \[from\]-\[to\]

#endif

**#input\_string**

#input\_string str\_var Заголовок

переменные заполняются после завершения диалога:

#input\_string\_ok - результат 0/1

#input\_string\_clipboard - значение вставлено из буфера обмена

#input\_string\_ticks - количество миллисекунд от ввода первого и последнего символа

Пример использования:

#v str=123

#input\_string str введи строку

#if $input\_string\_ok

#msg \[str\]

#endif

**#msg #m**

#msg - вывести сообщение

Пример использования:

#msg текст

форматирование:

Пример использования:

#v msg\_color=clYellow

#msg Желтый

**#message\_query #m\_q**

#message\_query - Запросить подтверждение

Пример использования:

#message\_query res Вопрос

#if $res

#msg OK

#endif

**#input\_text #show\_text**

Редактирование или просмотр данных(текста) в переменной

формат

;редактирование

#input\_text имя\_переменной Заголовок

;просмотр

#show\_text имя\_переменной Заголовок

в окне ввода текста отразится значение переменной как данные по умолчанию

Спец переменная input\_text\_wordwrap = 0/1 указывает надо ли разбивать текст по словам

Пример использования:

#s komm\_var=значение по умолчанию

#input\_text komm\_var Введите комментарий

#if !\[input\_text\_ok\]

#exitproc

#endif

#msg komm\_var=\[komm\_var\]

**#input\_fastnum**

ввод данных без задержки (с устройства например сканера), для того чтобы нельзя было ввести данные вручную с клавиатуры

формат

#input\_fastnum имя\_переменной,show\_num,Заголовок окна

show\_num: показать номер: 0 или 1

переменные которые возвращаются

input\_fastnum\_ok - результат 0/1

input\_fastnum\_clipboard - значение вставлено из буфера обмена

input\_fastnum\_ticks - количество миллисекунд от ввода первого и последнего символа

Пример использования:

#s show\_num=0

#s num=

#input\_fastnum num,\[show\_num\],Введи номер карты

SELECT '\[num\]' as номер

**#select\_dir**

Диалоговое окно выбора каталога, в переменную записывается полный путь к каталогу

формат

#select\_dir имя\_переменной,название\_окна

Пример использования:

#s dir=

#select\_dir dir,Выбери путь

#if \[select\_dir\_ok\]

#msg dir=\[dir\]

#endif

**#select\_value**

Выбор одного или нескольких элементов из списка (список формируется sql запросом), по умолчанию выбран элемент со ссылкой равной значению переменной

формат

#select\_value <имя\_переменной> SQL\_запрос

в результате выполнения sql запроса ожидаются две колонки ССЫЛКА и НАИМЕНОВАНИЕ, в диалоге отобразится содержимое колонки НАИМЕНОВАНИЕ, в переменную вернется содержимой колонки ССЫЛКА. Доп колонки получаются из НАИМЕНОВАНИЯ используется разделитель \\r\\n - см пример для множественного выбора.

Спец переменные , установить до открытия диалога:

select\_value\_cap - задать заголовок окну

select\_value\_checks - режим множественного выбора (умолчание 0)

select\_value\_allowempty - разрешить пустой выбор (умолчание 0)

select\_value\_sort - сортировка списка (по умолчанию 1)

select\_value\_columns - Out который содержит форматы колонок в окне выбора

Пример использования:

#o select\_value\_columns

#r

col1\_name \[TAB\] text\_align \[TAB\] auto\_width \[TAB\] width \[TAB\] min \[TAB\] max

col2\_name \[TAB\] text\_align \[TAB\] auto\_width \[TAB\] width \[TAB\] min \[TAB\] max

..

/\*

Параметры:0 1     2     3     4

0-Название колонки

1-место положение текста

2 - авто

3 - ширина столбца

4 - минимальная ширена столбца

5 - максимальная ширена

\*/

**#select\_value\_tree**

выбор элемента из дерева, разделитель элементов дерева символ /

формат

#select\_value\_tree <имя\_переменной> SQL\_запрос

в результате выполнения sql запроса ожидаются две колонки ССЫЛКА и НАИМЕНОВАНИЕ (разделитель элементов дерева символ /), в диалоге пользователю отобразится содержимое колонки НАИМЕНОВАНИЕ, в переменную вернется содержимой колонки ССЫЛКА

пример

#set mm=Новосибирск

#select\_value\_tree mm select  Наименование , CONCAT('Города/',Наименование) from spravochniki\_goroda limit 2

#msg \[mm\]

select '1' as '1'

**#input\_radio\_sw**

Выбор элемента в виде переключателей, можно задать элемент выбранный по умолчанию

формат

#input\_radio\_sw имя\_переменной,имя\_out,название\_в\_окне\_выбора

Пример использования:

#set var=alias\_2

#o out\_name

alias\_1=option 1

alias\_2=option 2

alias\_3=option 3

#input\_radio\_sw var,out\_name,TEXT MESSAGE HERE

#msg \[var\]

#reset

#o main

**#input\_string\_bymask**

#input\_string\_bymask имя\_переменной,значение\_маски\_ввода,заголовок\_окна

переменные заполняются после завершения диалога:

#input\_string\_bymask\_ok - результат 0/1

#input\_string\_bymask\_clipboard - значение вставлено из буфера обмена

#input\_string\_bymask\_ticks - количество миллисекунд от ввода первого и последнего символа

Пример использования:

#s val=

#s mask=000

#input\_string\_bymask val,mask,Введи 3 числа

#if \[input\_string\_bymask\_ok\]

#msg Введена строка \[val\] за \[input\_string\_bymask\_ticks\] милисекунд , избуфферобмена= \[input\_string\_bymask\_clipboard\]

#endif

**#error\_msg**

вывести расширенное сообщение об ошибке:

#error\_msg <short\_error>|<describtion>

<short\_error> - короткое сообщение об ошибке

<describtion> - описание, появится

#error\_msg <short\_error>|<describtion>

форматирование:

#v msg\_color=clYellow

#error\_msg Желтый

**#show\_hint #show\_err\_hint #show\_color\_hint**

Пример использования:

#show\_hint Message

показывает всплывающее короткое сообщение

#show\_err\_hint Message

показывает всплывающее короткое сообщение на красном фоне

#show\_color\_hint bg\_color fg\_color Message

показывает всплывающее короткое сообщение, заданного цвета фона и текста

**#usr\_query #u\_q #uq**

#usr\_query btn1;btn2;..|message

Выводит сообщение с набором указанных кнопок

Возвращает нажатую кнопку \[usr\_query\]

Пример использования:

#usr\_query save it;cancel;close|Not Saved!

#if $usr\_query=save it

  ...

  #msg Saved

#endif

**#gui\_mode  #get\_gui\_mode**

Запрет использования gui директив:

#gui\_mode 0

При попытке вызывать gui директивы будет exception.

#msg ...

#input\_text..

 и тп

Разрешить использование gui директив (по умолчанию разрешено)

#gui\_mode 1

Проверить разрешение

#get\_gui\_mode

\[get\_gui\_mode\] 0/1

**#select\_sorted\_fields**

#v select\_sorted\_fields\_caption=Заголовок

#select\_sorted\_fields items\_var, item1,item2..

показывает диалог выбора и сортировки

#v items\_var=1,2,3

#v select\_sorted\_fields\_caption=Выбери цифры

#select\_sorted\_fields items\_var,1,2,3,4,5,6

#if $select\_sorted\_fields\_ok

  ..\[items\_var\]=<выбранные items в указанном порядке через запятую>

#endif

  

  

#### 6.Параметр Enviroment

**#env\_get\_env**

получает название текущего env(таблицы.параметрысреды) в переменную env\_get\_env

формат

#env\_get\_env

Пример использования:

#env\_get\_env

#msg env\_get\_env=\[env\_get\_env\]

**#env\_set\_env #env\_env**

Переключает на заданный enviroment

формат

#env\_set\_env имя\_enviroment

Пример использования:

#env\_set\_env PUK

**#env\_params\_set**

Устанавливает значение параметра текущего env из заданной переменной

формат

#env\_params\_set имя\_параметра\_env

Пример использования:

#s Параметр=Значение

#env\_params\_set Параметр

**#env\_params\_refresh**

Параметры среды считываются из БД в момент авторизации в программе.

Также синхронизация параметра происходит в момент установки.

Для принудительного обновления предзагруженных параметров используется команда #env\_params\_refresh

#### 7.Работа с событиями внутри приложения и отправки в систему

**#event\_add\_listener  #event\_del\_listener**

Задаёт обработчик событий (listener) , при активации которого выполняется указанная процедура (можно передавать параметры в процедуру), аналог

формат

#event\_add\_listener имя\_события=имя\_выполняемой\_процедуры

#event\_del\_listener имя\_события=имя\_выполняемой\_процедуры

Вызвать событие можно из любой формы и модуля

Пример использования:

#event\_add\_listener ЖурналИнвойсовИПриходов\_ВыборЗаказа=СоздатьИнвойс

**#event\_exec #event\_post**

Отправка сообщения указанному listener

#event\_exec - поток ждёт выполнения всех процедур listener, в процедуры listeners передается текущий out

т.е. результат работы можно вернуть в out

#event\_post - поток не ждёт выполнения процедур listener, аналогична

передача параметров как при вызове процедуры

формат

#event\_postимя\_listener(параметр1,параметр2...)

пример

#event\_post СегментацияКлиентов\_ИзменениеФильтра($сегментация\_ссылка,$строка\_фильтр)

**#msg\_post**

Отправка сообщения аналогична

формат

#msg\_post имя\_listener параметр1,параметр2...

Пример использования:

#msg\_post Фискальная\_операция Cassa,Sum

**#message\_add #message\_del**

Задаёт или удаляет обработчик событий (listener) , при активации которого выполняется указанная процедура (можно передавать параметры в процедуру)

формат

#message\_add имя\_события=имя\_выполняемой\_процедуры

#message\_del имя\_события=имя\_выполняемой\_процедуры

#win\_msg\_post  #win\_msg\_post\_ex

Отправить сообщение windows

#win\_msg\_post winhandle(0 for all) wparam lparam

Отправляет WM\_USER

#win\_msg\_post\_ex winhandle(0 for all) win\_msg\_id(0 for WM\_USER) wparam lparam

Отправляет сообщение указанного типа

Для отправки сообщений между приложениями, нужно их регистрировать предварительно

#event\_listener\_count

#event\_listener\_count event\_name

возвращает в переменной event\_listener\_count

текущее количество listeners для указанного события

#msg\_post\_form #event\_post\_form #event\_exec\_form

  

#msg\_post\_form 

#event\_post\_form

#event\_exec\_form

аналогично командам

#msg\_post

#event\_post

#event\_exec

только получатели будут обработчики связанные с текущей формой.

  

  

#### 8.Вызов и обработка исключений

**#exception**

Прерывание выполнения

формат

#exception имя\_контекста;функция\_контекста;сообщение

Пример использования:

#exception new\_doc;открыть док;Нет доступного количества км для перемещения

**#try #catch #endtry**

Позволяет выполнить код если внутри происходит exception и обработать возникшее исключение, доступна информация о проишедшем exception

формат

#try

выполняемый\_код\_с\_ошибками

#catch

выполняемый\_код\_если\_произошел\_exception

#endtry

Всегда должен быть #catch : #try .. #catch .. #endtry так нельзя : #try .. #endtry - бага

Пример использования:

; допускается вложенное использование TRY

; TRY открывает новый блок, переменные объявленные внтури TRY после ENDTRY недоступы.

#try

;     #exception ExceptionClass;Сообщение пользователю;Служебное сообщение

      #try

           #call tst

      #catch

           #msg Ошибка, catch#1:\[?%exception.msg\]

           #exception \[?%exception.class\];\[?%exception.short\_msg\];\[?%exception.msg\]     

  

      #endtry

#catch

; Служебные переменные об инфе по исключению

      #msg

      #> in catch

      #> exception\_class=\[?%exception.class\]

      #> exception\_msg=\[?%exception.msg\]

      #> exception\_short\_msg=\[?%exception.short\_msg\]

      #> exception\_pos=\[?%exception.pos\]

      #> exception\_proc=\[?%exception.proc\]

      #> exception\_cmd=\[?%exception.cmd\]

      #> exception\_src\_line=\[?%exception.src\_line\]

      #> exception\_parsed\_line=\[?%exception.parsed\_line\]

      #> exception\_stack=\[?%exception.stack\]

      #exception EXCEPTION      

  

#endtry

  

**#onexception**

Задает команду для выполнения в случае exception

#onexception cmd

Пример использования:

#onexception #msg ошибка!

  

  

#### 9.Работа с файлами

**#check\_file**

Проверить существование файла

Пример использования:

#check\_file full\_file\_path

#check\_file c:\\sp\\sp.ini

в переменной check\_file содержит результат проверки 1/0

**#copy\_file**

Копирование файла

#copy\_file c:\\tmp.tmp;c:\\tmp2.tmp

переменные

copy\_file содержит результат копирования

copy\_file\_error описание ошибки

если файл существует , он будет заменен на новый.

**#enum\_files**

Получает список файлов в папке, по маске

Пример использования:

#enum\_files c:\\tmp\\;\*.\*

список файлов будет выведен в текущий

**#delete\_file**

Удалить файл

#delete\_file file\_full\_path

удаляет файл по полному пути file\_full\_path

Результат в переменной delete\_file = 0/1

**#rename\_file**

Переименовать файл

Пример использования:

#rename\_file filename\_from;filename\_to

#rename\_file c:\\tmp\\tmp;c:\\tmp\\tmp2

Локальная переменная rename\_file будет содержать результат 0/1

**#extract\_file\_ext**

Извлекает расширение файла

#extract\_file\_ext c:\\tmp.tmp

результат в переменной extract\_file\_ext

**#extract\_file\_name**

Извлекает имя файла

#extract\_file\_name c:\\tmp.tmp

результат в переменной extract\_file\_name

**#extract\_file\_path**

Извлекает путь к файлу

#extract\_file\_path c:\\tmp.tmp

результат в переменной extract\_file\_path

**#get\_file\_size**

Получить размер файла в байтах.

#get\_file\_size filename

Пример использования:

#get\_file\_size c:\\tmp.tmp

переменная get\_file\_size будет содержать результат

**#get\_file\_date**

Получить дату изменения файла .

#get\_file\_date filename

Пример использования:

#get\_file\_date c:\\tmp.tmp

переменная get\_file\_date будет содержать результат в формате yyyy.mm.dd hh:nn:ss

**#save\_to\_file #load\_from\_file**

Сохранить или прочитать содержимое переменной в/из файла

При необходимости создает путь файла.

#save\_to\_file var\_name,file\_name,mode (a+b,w+b)

#load\_to\_file var\_name,file\_name

варианты с промежуточным преобразованием:

save\_to\_file\_utf8

save\_to\_file\_oem

save\_to\_file\_bin (если был прочитан load\_from\_file\_bin)

save\_to\_file\_encode\_base64

save\_to\_file\_decode\_base64

save\_hex2bin\_file

load\_from\_file\_utf8

load\_from\_file\_escape - экранирует для вставки в базу

load\_from\_file\_bin

load\_from\_file\_oem

load\_from\_file\_encode\_base64

load\_bin2hex\_file

при ошибках вызывает исключение

**#set\_file\_date**

Установить дату изменения файла .

#set\_file\_date filename,filedate

Пример использования:

#set\_file\_date c:\\tmp.tmp,2001-01-01 12:30:00

переменная set\_file\_date\_ok будет содержать результат 0/1

**#force\_directories**

Создание папок.

Создает промежуточные папки при необходимости

#force\_directories c:\\temp\\sp\\spstore

**#file\_zip**

Добавляет все файлы и папки по патерну в архив из папки

#file\_zip basedir, pattern, archivename

**#file\_unzip**

Извлекает из архива файлы в указанной папке

#file\_unzip basedir, pattern, archivename

**#sys\_add\_listendir\_event**

#sys\_add\_listendir\_event dir\_full\_name

Включить наблюдение за директорией

при изменении файлов в директории будет доступны 2 события

dir\_change\_event - для всех директорий на которых включенно наблюдение, параметр в событии - директория

dir\_change\_event::\[dir\_full\_name\] - только для директории

Пример использования:

#sys\_del\_listendir\_event C:\\sp

#event\_del\_listener dir\_change\_event=proc\_name

#event\_del\_listener dir\_change\_event::C:\\sp=proc\_name2

#msg Регистартор событий отключен для папки c:\\sp

**#sys\_del\_listendir\_proc**

#sys\_del\_listendir\_proc full\_dir\_name

выключить наблюдение за директорией или файлом

**#sys\_del\_listendir\_event**

#sys\_del\_listendir\_event full\_dir\_name

выключить наблюдение за директорией

**#sys\_add\_listendir\_proc**

  

#sys\_add\_listendir\_proc proc\_name=dir\_full\_name

Включить наблюдение за изменением файлов в директорией или за отдельным файлом

при изменении файлов в директории будет вызван обработчик proc\_name

Пример использования:

#proc enable

  #sys\_add\_listendir\_event onchange=C:\\sp

  #msg Регистартор событий отключен для папки c:\\sp

#endproc

#proc onchange

  #msg файл изменен!

#endproc

#proc disable

  #sys\_del\_listendir\_event C:\\sp

#endproc

  

  

#### 10.Http запросы

**#http\_get**

#http\_get request\_out,result\_out,url

выполнить http GET запрос

url Должен быть UTF8 и URLENCODED

request\_out для http\_get не используется, можно указать не существующий

Пример использования:

#s msg=пример отправки

#ansitoutf8 msg

#http\_get no\_used,result,[https://api.com?msg=\[msg\]](https://api.com?msg=[msg])

#msg Ответ: \[$out::result\]

OUT result будет содержать результат запроса – BODY

  

  

#### 11.LabelPrinter для работы через интерфейс принтера этикеток

**#splp\_connect**

Подключение к PrintServer для печати на принтере этикеток

#splp\_connect host:port,interactive

interactive - не обязательный параметр, значение по-умолчанию 1.

значение 1 - не блокировать дальнейшее выполнение макроса при появлении ошибок на принтере, вывод сообщение

значение 0 - вызывает exception , при получении ошибки от PrintServer

host:port - сетевой адрес и порт для подключения. Не обязательные параметры, - значение по-умолчанию 127.0.0.1:15151 соответственно

Примеры использования:

#splp\_connect

Подключение к PrintServer по адресу 127.0.0.1:15151

#splp\_connect 192.168.10.3

Подключение к PrintServer по адресу 192.168.10.3:15151

  

**#splp\_print\_template**

Вызов печати этикетки по шаблону

#splp\_print\_template print\_template

print\_template - наименование шаблона этикетки из таблицы spravochniki\_shablonipechatietiketok

В текущем out могут содержаться определение параметров, используемых в шаблоне

Пример использования:

#o params

Артикул=1234-45

Код=58596

ШтрихКод=034782736

АртикулПоставщика=M93902dfj-001

#splp\_print\_template ЦенникНАТовар

**#splp\_send\_out**

Отправка команд печати из текущего out на PrintServer

Пример использования:

#o Sticker

#r

I8,C,41

rY

R26,5

Q200,019

q470

ZT

JF

N

A360,178,2,2,1,1,N,"Строка 1"

A360,162,2,2,1,1,N,"Строка 2"

P1

#splp\_send\_out

**#splp\_check**

Проверка наличия соединения с PrintServer

Результат в переменной с именем splp\_check\_ok

Пример использования:

#splp\_check

#if !\[splp\_check\_ok\]

#msg Принтер этикеток не доступен

#endif

  

  

#### 12.Работа с циклами

**#for #endfor #break**

Цикл

1.поход по списку (n1,..,n2)

Пример использования:

#for i=(1,2,3,4,5,..,N)

 #msg \[i\]

#endfor

использование разделителя отличного от запятой

  

#for i=(1,2|3,4|5,6|..|N)/|

 #msg \[i\]  // 1,2   3,4 

#endfor

проход по переменным

  

#s (a,b,c)=1,2,3

#for i=($a,$b,$c,4)

 #msg \[i\]  // 4-ре сообщения: 1 2 3 4

#endfor

проход по src полям

  

#src dep

#r

select \* from spravochniki\_podrazdeleniya

limit 1

#query

#endsrc

  

#for i=($@dep.Код,$@dep.Наименование)

 #msg \[i\]  // 2-а сообщения: Код и Наименование

#endfor

2\. классический вариант

  

#for i=start,end,inc

...

#endfor

  

#for i=0,10,1

...

#endfor

внутри цикла доступны служебные переменные

| %%loop | содержит команду for foreach foreach\_out |
| ---| --- |
| %%for cmd | содержит командную строку целиком |
| %%index | содержит название переменой индекса (i) |
| %%for\_pos | индекс старт |
| %%for\_step | шаг |
| %%for\_to | индекс стоп |
| %%start\_position | номер строки после оператора цикла #for |
| %%end\_position | номер строки перед #endfor |

Прерывание цикла #break

  

**#foreach**

Цикл по резалтсету источника

Оператор инициирует курсор в начала ресалтсета, внутри цикла доступна строка источника данных

**#foreach srcname**

#msg {srcname.fieldname}

#endfor

Если источник пустой цикл не выполняется.

Прерывание и служебные переменные аналогично

**#foreach\_out**

Цикл по out

Пример использования

#o outname

#r

line1

line2

**#foreach\_out outname**

#msg \[outname\] //line1 .. line2

#endfor

Внтутри цикла доступна переменная с таким же названием как имя аута

которая содержит строку из аута.

Служебные переменные аналогичны #for #endfor #break

%%index содержит номер строки начиная с 0.

**#continue**

для #for #foreach #foreach\_out

переход к следующему элементу обхода

  

  

#### 13.Инструменты для работы с модулями

**#include\_module**

Подключает процедуры описанные в модуле (таблица справочники.модули)

формат

Пример использования:

#include\_module реф\_модуля

допустипо указать через запятую, модули будут выбраны за один запрос,

что может быть заметно при медленном подключении.

#include\_module module1,module2,?module3

  

  

#### 14.MReport Grid доступные в контексте формы отчета

**#set\_row\_height**

Установить высоту строк

#set\_row\_height value

**#grid\_select\_row**

Переместить курсор на строку по номеру, нумерация строк с 0

#grid\_select\_row row\_id

**#get\_row\_values**

Чтение значений ячеек из указанной строки

#get\_row\_values row\_id Col\_caption1\[, ...Col\_captionN\]

row\_id - номер строки

Col\_caption - полное наименование столбца

Список столбцов через запятую

#get\_row\_values 5 Артикул,Код,gg::Подразделение

Из строки номер 5 прочитаны значения из столбцов \`Артикул\`,\`Код\`,\`gg::Подразделение\`

Далее значения доступны как переменные с названиями по имени столбцов \[gg::Подразделение\] \[Код\]

**#get\_row\_vals**

Чтение значений ячеек из указанной строки

#get\_row\_vals row\_id Col\_caption1\[, ...Col\_captionN\]

row\_id - номер строки

Col\_caption - полное наименование столбца

Список наименований столбцов через ;

#get\_row\_vals 5 Артикул;Код;gg::Подразделение

Из строки номер 5 прочитаны значения из столбцов \`Артикул\`,\`Код\`,\`gg::Подразделение\`

Далее значения доступны как переменные с названиями по имени столбцов \[gg::Подразделение\] \[Код\]

**#set\_progress**

Управление значением и отрисовкой ProgressBar

#set\_progress value

value целые числа от 0 до 100

**#set\_short\_msg**

Вывод текста под таблицей основного запроса

#set\_short\_msg text\_value

**#requery**

Работает только в контексте отчета Форма отчета

Запуск обновления в отчете, равноценно нажатию кнопки обновить в отчете.

**#get\_col\_caption**

Пример использования:

#get\_col\_caption col\_num var\_name

помещает в переменную var\_name заголовок колонки по номеру col\_num

  

  

  

#### 15.Работа с ORM

**#update\_obj #transaction\_update\_obj**

Загрузка или обновление любых объектов ORM через выполнение body file.

Объект должен быть описан в метаданных (конфиге).

В переменной update\_obj\_flags могут быть переданы флаги

CreateNew; - создавать новые объекты

ModifyObject; - изменять существующие

ModifyRefs; - разрешить изменять ссылки

DoNotSaveNotFounded; - записывать в не найденные, если не удалось разрешить все поля или провести документ

DoNotPostDocs; - не проводить документы

RefsMustBe; - не разрешать запись если ссылка не определена

NotRiseException; - не вызывать exception

Если flag пустой или =0 тогда установлены по умолчанию

#update\_obj принимает на входе текст из в формате

Переменная update\_obj\_count или update\_obj\_transaction\_count будет содержать количество

обновленных или созданных объектов.

Пример использования:

#o body

#r

Объект:Справочники.Интерфейсы

Ссылка:d6a947d8-8ffc-102b-a724-329a6e576a0f

Родитель:c50cca09-a5da-102b-a724-329a6e576a0f

тип\_элемента:ЭЛЕМЕНТ

Наименование:Кассир Мармалато

Описание:Интерфейс кассира мармалато

.

#s update\_obj\_flags=CreateNew;ModifyObject;ModifyRefs;RefsMustBe;NotRiseException;

#update\_obj

#msg cnt=\[update\_obj\_count\]

**#spdoc\_set\_state**

Установить статус документа

#spdoc\_set\_state \[ссылка документа\],\[СТАТУС\]

СТАТУС = { ПРОВЕДЕН || НЕПРОВЕДЕН || ОТМЕНЕН }

#spdoc\_set\_state 432322,ПРОВЕДЕН

**#spdoc\_repost**

перепроводит документ в одной транзакции

#spdoc\_repost ссылка документа

**#obj\_delete**

Удалить объект

#obj\_delete Полное имя документа:ссылка

Пример использования:

#obj\_delete Справочники.Кассы:1

**#obj\_rehash**

пересоздает кэш для иерархичного объекта

#obj\_rehash <Имя объекта>

Пример использования:

#obj\_rehash Справочники.Контрагенты

**#sp\_current\_user**

Процедура получает реквизит текущего пользователя, в одноименную переменную

Пример использования:

#sp\_current\_user имя\_реквизита

#sp\_current\_user Наименование

#msg Привет \[Наименование\]

**#spdoc\_call**

#spdoc\_call class\_func\_name

Вызов функции проведения документа по имени процедуры.

Выполнить можно только в контексте процедуры проведения spmacro

где class\_func\_name имя процедуры

Пример

Если например для документа нужно запустить определенную процедуру , но эта процедура не реализует определенное условие , делаем процедуру проведения "прокладку" на spmacro

там проверяем условие и из нее вызываем нужную процедуру через #spdoc\_call.

В функцию будут переданы все параметры указанные для функции "прокладки"

  

  

#### 16.Работа с out

**#out\_copy\_to\_clipboard**

копирует содержимое аута в буфер обмена

формат

#out\_copy\_to\_clipboard имя\_аута

**#out\_save\_to\_file**

Сохранить out в файл

#out\_save\_to\_file out\_name,filename

Добавить строки в файл

#out\_save\_to\_file\_a out\_name,filename

out\_name - имя out, не обязательный параметр

filename - путь и имя файла для сохранения

Пример использования:

#o newout

#r

save text

#out\_save\_to\_file ,c:\\temp\\newfile.txt

В файле c:\\temp\\newfile.txt значение "save text"

**#out\_save\_to\_var**

Сохранить значение out в переменную

#out\_save\_to\_var out\_name,var\_name

out\_name - имя out, не обязательный параметр, если не указывать, то в переменную будет сохранено значение текущего out

var\_name - имя переменной для сохранения

Пример использования:

#o newout

#r

save text

**#out\_save\_to\_var var\_text**

В переменной var\_text значение "save text"

#r

Очистить текущий out или src

#o

Переключение на другой out

#o out\_name

out\_name - Имя out

**#out\_to\_params**

Создает и заполняет переменные по содержимому текущего out

Формат:

var\_name=var\_value

Пример:

#o params

#r

_var1=string value a_

_var2=string value b_

_var3=string value c_

#out\_to\_params

В результате будут созданы 3 переменных var1,var2,var3 с соответствующими значениями

Аналогично #s var1=string value a

**#out\_get\_count**

Количество строк в out

**#out\_get\_count str\_count,out\_name**

В переменную str\_count будет записано количеств строк, содержащееся в out\_name

**#out\_load\_from\_file**

Загрузка в out содержимое файла

#out\_load\_from\_file out\_name,file\_name

#out\_load\_from\_file outres,c:\\temp\\newfile.txt

вариации команды

#out\_load\_from\_file\_utf8 - если файл в utf8

#out\_load\_from\_file\_oem

**#out\_save**

Зафиксировать текущий out

для последующего перехода обратно при помощи команды #out\_restore

**#out\_restore**

Переход на ранее зафиксированный out

#out\_restore out\_name

#proc proc1

#out\_save outproc1

#o outtmp

. . .

#out\_restore outproc1

#endproc

В результате #out\_restore текущий out будет назначен первоначальный out процедуры

**#out\_reset**

Очистка текущего out

Синоним команды #r

**#out\_load\_from\_var**

Загрузка значения переменной в out

**#out\_load\_from\_var out\_name,var\_name**

Значение из переменной var\_name будет загружено в out\_name

**#out\_send\_to\_clipboard**

Отправка значения out в буфер обмена

**#out\_send\_to\_clipboard out\_name**

Если не указано имя out, будет использован текущий

**#out\_get\_line**

Чтение строки N из out. Нумерация строк с 0

**#out\_get\_line var\_name,out\_name,num**

В переменную с именем var\_name будет записана строка с номером num из out с именем out\_name

#o otest

строка 1

строка 2

строка 3

#o main

#out\_get\_line str,otest,1

в переменной str строка со значением "строка 2"

**#out\_to\_ex\_params**

Создает и заполняет глобальные переменные по содержимому текущего out

Формат:

var\_name=var\_value

Пример использования:

#o params

#r

var1=string value a

var2=string value b

var3=string value c

**#out\_to\_params**

В результате будут созданы 3 глобальных переменных var1,var2,var3 с соответствующими значениями

Аналогично #se var1=string value a

**#out\_release**

Удаление out и его содержимого

**#out\_release out\_name**

**#out\_save\_to\_file\_utf8 #out\_save\_to\_file\_oem**

кодировки cp=utf8,oem

Сохранить out в файл с кодировкой UTF8

**#out\_save\_to\_file\_\[cp\] out\_name,filename**

Добавить строки out в файл с кодировкой UTF8

**#out\_save\_to\_file\_\[cp\]\_a out\_name,filename**

out\_name - имя out, не обязательный параметр

filename - путь и имя файла для сохранения

Пример

#o newout

#r

save text

#out\_save\_to\_file\_\[cp\] ,c:\\temp\\newfile.txt

В файле c:\\temp\\newfile.txt значение "save text"

#out\_utf8toansi

Перекодирование содержимого out из utf8 в ANSI

#out\_utf8toansi out\_name

Если out\_name не задано, - используется текущий out

#out\_ansitoutf8

Перекодирование содержимого out из ansi в utf8

#out\_ansitoutf8 out\_name

Если out\_name не задано - используется текущий out

#out\_replace

Поиск и замена подстроки по шаблону

#out\_replace out\_name,var\_name\_patern,\[str\]

В out с именем out\_name будет заменены все вхождения строки, содержащейся в переменной var\_name\_patern , на строку в переменной str

Пример использования:

#s substr=Строка

#o textout

Строка 1

Строка 2

Строка 3

#out\_replace textout,substr,->

Слово "строка" будет заменена на символы "->"

**#out\_switch**

Переключение текущего out на другой

#out\_switch out\_name

**#out\_add\_str**

Добавить строку в out без переключения в этот out

#out\_add\_str out\_name,string

**#out\_add\_out**

Добавить все строки из одного out в другой

#out\_add\_out out\_name\_to,out\_name\_from

**#out\_copy\_from**

Копировать в текущий out строки из указанного

#out\_copy\_from outname

**#out\_exec\_to\_out**

Выполнить макрос в out\_src dst\_out будет использован для вывода

#out\_exec\_to\_out src\_out,dst\_out

**#out\_copy\_to\_proc**

Создать из out процедуру

#out\_copy\_to\_proc \[out\_name,\]proc\_name

out\_name не обязательный параметр, будет использован текущий out

  

#out proc

#r

#msg HELLO

#out\_copy\_to\_proc proc,myProc

#call myProc

**#out\_get\_from\_clipboard**

Заполнить текущий out или указанный содержимым буфера обмена

#out\_get\_from\_clipboard \[out\_name\]

**#out\_save\_to\_clipboard**

Заполнить буфер обмена содержимым из текущего out или указанного.

#out\_save\_to\_clipboard \[out\_name\]

синонимы

#out\_copy\_to\_clipboard

#out\_send\_to\_clipboard

**#reset #r**

Очистить текущий **out** или **src**

**#out\_export**

При завершении процедуры установить указанный out для вывода.

Использовать с осторожностью.

**#out\_to\_log**

Вывести текущий или указанный out в лог, если он задан.

Лог вывода задается например в конструкторе формы отчета.

**#out\_set\_line**

Задать изменить строку в out

#out\_set\_line out\_name,line\_index=(0..N-1),value

N=количество строк

**#out\_ins\_line**

Вставить строку в out

#out\_ins\_line out\_name,line\_index=(0..N-1),value

N=количество строк

  

  

#### 17.Управления процессами

**#cancel**

Завершает текущую процедуру, удаляет добавленные внутри процедуру строки в out

Пример использования:

#proc test

1

2

3

#case \[cancel\] #then #cancel

#endproc

#call

Вызов заданной процедуры с параметрами

Пример использования:

формат

#call имя\_процедуры(параметр1,параметр2...)

**#endproc**

Завершение кода процедуры

Пример использования:

#proc 1

...

#endproc

**#exitproc**

Выход из контекста выполнения текущей процедуры

Пример использования:

#proc1

#msg 1

#exitproc

#msg 2

#endproc

#call proc1

**#proc**

Объявляет процедуру, в скобках указываются названия переменных для передачи параметров

формат

#proc имя\_процедуры(парам1,парам2)

Примеры использования:

  

#proc proc1(p1,p1)

#msg p1=\[p1\] p2=\[p2\]

#endproc

  

#call proc1(n,b)

процедура с параметрами по умолчанию

  

#proc proc1(p1,p1:=1)

#msg p1=\[p1\] p2=\[p2\]

#endproc

  

#call proc1(1) => msg p1=1 p2=1

  

процедура с объединением параметров

  

#proc proc1(p1,...args)

#msg p1=\[p1\] other args=\[?args\]

#endproc

  

#call proc1(1,2,3,4) => msg p1=1 args=2,3,4

**#exit**

Завершение выполнения процедуры и всех вложенных процедур по стеку вызова.

Пример использования:

#proc2

#exit

#endproc

  

#proc1

#msg 1

#call proc2

#msg 2

#endproc

  

#call proc1

Условное завершение

  

; выход если переменная do\_exit содержит 1

#exit ? $do\_exit=1

  

  

#### 18.Src и Transactions

**#transaction\_state**

#transaction\_state \[connection\_name\]

есть тэг функция

установит переменную transaction\_state=0,1,2,3..

0 - транзакция не начата

N - уровень сложенности транзакции

не проверяет запущена ли транзакция для подключения!

только если запущено через ORM

**#transction\_start**

или контекст функции проведения документа

<src multi>

несколько источников src за один запрос к БД

Пример использования:

#src asd

  select 1;

  select 2;

#query  asd=(asd1,asd2)

#endsrc

  

результат:

{asd1}  1

{asd2}  2

асинхронный запрос

  

#src asd

  select 1;

  select 2;

#query\_async  #connection1 asd=(asd1,asd2)

#endsrc

  

#query\_async\_get asd=(asd1,asd2) \[timeout\]

...

Результат:

{asd1}  1

{asd2}  2

#srcmap stage2

{src\_m} - количество ключей

{src\_m(key\_val)} - количество строк по ключу

; обход ключей

#foreach src\_m

; обход ключа

#foreach src\_m(\[src\_m\])

#msg {src\_m.<field>}

#endfor

#endfor

#srcmap stage1

ассоциативный массив из src

#srcmap src\_m=src(col1,col2...)

·быстрый доступ к строке по ключу

{src\_m(val1,val2..).field}

{src\_m(val1,val2..)#size}

**#srcmap**

#srcmap srcmap\_name=src\_name(key1\[,key2,..\])

Проходит по заданному src cоздает ассоциативный массив.

key1\[,key2,..\] - названия колонок в src которые сформируют ключ

Значения колонок key1\[,key2,..\] для каждой будут объеденены через знак | , и приведены к нижнему регистру.

Ключ не чувствителен к регистру.

src должен быть инициирован

Пример использования:

**#src deps**

select \* from spravochniki\_podrazdeleniya

#query

#endsrc

#srcmap podr=deps(Код)

варианты использования:

1) поиск строки в src по ключу

{srcmap\_name(key\_val).field}

для доступа по составному ключу

{srcmap\_name(key\_val1|key\_val2...).field}

пример

{podr(000).Наименование} = наименование подразделения с кодом 000

2) обход ключей srcmap

  

**#foreach key in podr**

 \[key\] =..значения ключа

#endfor

  

#foreach key=podr

 \[key\] =..значения ключа

#endfor

  

**#foreach podr**

 \[podr\] =..значения ключа

**#endfor**

для нашего примера выше будет обход по всем кодам подразделений, так как ключ КОД уникальный для строки

если ключ не уникальный для строки src , например Родитель при обходе каждый родитель возникнет 1 раз.

3) Обход строк srcmap для заданного ключа. Пробегает по всем строкам src у которых заданный ключ

#foreach podr(значение\_ключа)

.. ... {podr.Наименование}

#endfor

  

#foreach podr(000)

 {podr.Наименование} = ..Склад

**#endfo**

Если ключ уникальный обход можно не делать там будет одна строка, см. пункт 1).

{srcmap} - вернет количество уникальных ключей

{srcmap(значение\_ключа)} - вернет количество строк с таким ключом

**#query\_async\_connection\_id**

Получение connection\_id асинхронного query.

Пример использования:

#query\_async\_connection\_id src\_name

\[query\_async\_connection\_id\]    //  select connection\_id()

Если запрос не активен (завершился или еще не начал выполнятся) вернет 0

  

  

  

  

#### 19.Работы со строковыми типами данных

**#ansitoutf8**

Перекодирование содержимого переменной из кодировки ANSI в UTF8

#ansitoutf8 var\_name

В переменной с именем var\_name сохранится строка в кодировке UTF8

#s str=строка

#ansitoutf8 str

**#utf8toansi**

Перекодирование содержимого переменной из кодировки UTF8 в ANSI

#utf8toansi var\_name

В переменной с именем var\_name сохранится строка в кодировке ANSI

#s str=строка

#utf8toansi str

**#str\_replace**

Заменяет все вхождения указанной строки.

#str\_replace var\_name\_txt,var\_name\_pattern,\[str\]

var\_name\_txt - имя переменной с исходным текстом

var\_name\_pattern - имя переменной с шаблоном подстроки

\[str\] - замещающая подстрока. Все вхождения строки var\_name\_pattern , найденные внутри строки var\_name\_txt , заменяются на значение \[str\].

Поиск вхождения без учета регистра

#s text=123456789

#s pattern=34

#s val=три

#str\_replace text,pattern,три

В переменной text результат 12три56789

**#num\_to\_phrase**

Преобразование числа в текст

#num\_to\_phrase var\_name

#s value=34

#num\_to\_phrase value

В переменной value = тридцать четыре

**#replace\_str**

Заменяет все вхождения указанной строки.

#replace\_str var\_name\_txt,var\_name\_pattern,\[str\]

var\_name\_txt - имя переменной с исходным текстом

var\_name\_pattern - имя переменной с шаблоном подстроки

\[str\] - замещающая подстрока. Все вхождения строки var\_name\_pattern , найденные внутри строки var\_name\_txt , заменяются на значение \[str\].

Поиск вхождения без учета регистра

#s text=123456789

#s pattern=34

#s val=три

#replace\_str text,pattern,три

В переменной text результат 12три56789

**#to\_barcode128**

Кодирование текста в code128 для вывода штрихкода

#to\_barcode128 var\_name

#s text=fg3456

#to\_barcode128 text

В переменной text сохранено закодированное значение

Штрихкод можно вывести если вывести на печать или экран содержимое переменной

text используя шрифт barcode

**#str\_trim**

Удаление символы пробела в начале и в конце строки

#str\_trim var\_name

#s text= 34rty

#str\_trim text

В переменной text сохранится значение '34rty'

**#dispatch\_str**

Разделение строки на подстроки по разделителю

#dispatch\_str result\_var\_name,sep\_var\_name,source\_line\_value

Количество подстрок доступно через #count

\[result\_var\_name#count\]

В результате создается массив значений result\_var\_name, каждое из значений доступно по номеру, нумерация с 0

\[result\_var\_name#num\]

Пример:

#s line=12:45:67

#s sep=:

#dispatch\_str var,sep,\[line\]

#msg \[var#count\] \[var#0\] - \[var#1\]

/\* в сообщении - "3 12 - 45 " \*/

#json2xml

Преобразование текста из формата json в xml

#json2xml json\_src(out name),dst(var name),\[JSONx=1,JXNL=2,JSON\_LEX=3,TaggedXML(def)=4\]

json\_src - имя out, в котором текст в формате JSON

dst - имя переменной, куда сохранить результат

JSONx,JXNL,JSON\_LEX,TaggedXML форматы результата , по умолчанию 4

#o jsontext

#r

@!{

prod:2345,

name:"Тапки"

}!@

#json2xml jsontext,varxml

**#concat\_nn #concat**

#concat - сцепление двух строк, разделитель запятая,

#concat\_nn - "concat not null" пустые значения игнорируются

#concat\_nn var\_result\_name,add\_value

результат в переменной с именем var\_result\_name

Пример:

  

#s val=ty

#s s=

#concat\_nn s,\[?val\]

#concat\_nn s,\[?empty\]

#concat\_nn s,\[?val\]

В переменной s строка "ty,ty"

**#to\_hex**

Перевод каждого символа, содержащегося в строке, в 16ти ричную систему исчисления

**#to\_hex var\_name**

результат в переменной var\_name

Пример:

#s s=ABC

#to\_hex s

В переменной s значение "414243"

**#parse\_int**

#parse\_int var\_name

Преобразование значения переменной к целому числу.

Наличие символов отличных от цифр приведет к значению 0

Символы табуляции и пробелов в начале и конце строки игнорируются

переменная parse\_double\_ok содержит результат преобразования 1/0

Пример:

#s s= 34

#parse\_int s

В переменной s значение "34"

#s s=34в

#parse\_int s

В переменной s значение "0"

**#popword #fetch**

#popword var\_from,var\_to\[,delim chars\]

Извлечение из переменной var\_from по разделителю \[,delim chars\] и сохранение в переменную var\_to

В результате будут изменены обе переменный,

·из var\_from будет убрана часть включая разделитель

·в var\_to будет сохранен текст прочитанный из var\_from до разделителя

#s s=pp-45-rt-89

#popword s,d,-

Результат

d = pp

s = 45-rt-89

#s s=pp,45,rt,89

#popword s,d1

#popword s,d2

Результат

d1 = pp

d2= 45

s=rt,89

также можно указать список переменных (в переменных не должно быть запятых)

#s s=pp,45,rt,89

#popword s,(d1,d2)

Результат

d1 = pp

d2= 45

s=rt,89

**parse\_double**

#parse\_double var\_name

Преобразование значения переменной к дробному числу с плавающей запятой

Наличие символов отличных от цифр и разделителя дробной части (это , либо . ) приведет к значению 0

Символы табуляции и пробелов в начале и конце строки игнорируются

переменная parse\_double\_ok содержит результат преобразования 1/0

Пример:

#s s= 34,05

#parse\_double s

В переменной s значение "34.05"

#s s=34в

#parse\_double s

В переменной s значение "0"

  

  

#### 20.dec

**#dec**

Уменьшить число в переменной на указанную величину

#dec var\_name\[,val\]

если val не задано, - устанавливается значение 1

#s num=12

#dec num,10

В переменной num значение 2

#dec num

В переменной num значение 1

**#inc**

Увеличить число в переменной на указанную величину

#inc var\_name\[,val\]

если val не задано, - устанавливается значение 1

#s num=23

#inc num,5

В переменной num значение 28

#inc num

В переменной num значение 29

**#sp\_passwordhash**

Возвращает HASH по алгоритмы для хранения и сравнения слепка пароля

  

#sp\_passwordhash string

;\[sp\_passwordhash\] - string hash

**#def #define**

Определяет константу в зоне видимости SPExport

Время жизни констант определено временем жизни основного модуля SpExport

или дочернего (child SPExport) модуля.

  

#def asd=hello

#msg \[asd\]  // hello

#se #set\_ex\_param

Объявление внешней переменной (доступна во всех процедурах связанных модулей)

формат

#se Имя\_переменной=значение\_переменной

пример

  

#se p1=1

#s #set

Объявление локальной переменной (доступна в текущем контексте выполнения)

формат

#s Имя\_переменной=значение\_переменной

Пример использования:

#s p1=1

<split vars>

Инициализация нескольких переменных из строки

применим для команд

#s #set

#v #var

#se #set\_ex\_param

#def #define

пример

  

#v (a,b,c)=1,2,3

результат:

a=1

b=2

c=3

с указанием разделителя данных в значениях:

  

#v (a,b,c|-)=1-2-3

результат:

a=1

b=2

c=3

**#load\_from\_clipboard**

#load\_from\_clipboard var\_name

загружает из буфер обмена как текст в переменную

  

  

#### 21.Манипуляции с системными объектами Windows

**#screen\_getdim**

Читает разрешение заданное для экрана

#screen\_getdim

Задает переменные:

 screen.width

 screen.height

 screen.workarea.left

 screen.workarea.width

 screen.workarea.height

 [screen.workarea.top](http://screen.workarea.top)

 screen.desktop.left

  screen.desktop.Width

  screen.desktop.Height

  [screen.desktop.top](http://screen.desktop.top)

**#mouse\_getpos**

читает координаты курсора мыши

#mouse\_getpos

переменные:

mouse.x

mouse.y

**#sys\_add\_listendir\_event**

  

#sys\_add\_listendir\_event dir\_full\_name

Включить наблюдение за директорией

при изменении файлов в директории будет доступны 2 события

dir\_change\_event - для всех директорий на которых включенно наблюдение, параметр в событии - директория

dir\_change\_event::\[dir\_full\_name\] - только для директории

Пример использования:

#sys\_del\_listendir\_event C:\\sp

  

#event\_del\_listener dir\_change\_event=proc\_name

#event\_del\_listener dir\_change\_event::C:\\sp=proc\_name2

  

#msg Регистартор событий отключен для папки c:\\sp

**#sys\_del\_listendir\_proc**

#sys\_del\_listendir\_proc full\_dir\_name

выключить наблюдение за директорией или файлом

**#sys\_del\_listendir\_event**

#sys\_del\_listendir\_event full\_dir\_name

выключить наблюдение за директорией

**#sys\_add\_listendir\_proc**

  

#sys\_add\_listendir\_proc proc\_name=dir\_full\_name

Включить наблюдение за изменением файлов в директорией или за отдельным файлом

при изменении файлов в директории будет вызван обработчик proc\_name

Пример

  

**#proc enable**

  #sys\_add\_listendir\_event onchange=C:\\sp

  #msg Регистартор событий отключен для папки c:\\sp

#endproc

  

#proc onchange

  #msg файл изменен!

#endproc

  

#proc disable

  #sys\_del\_listendir\_event C:\\sp

#endproc

**#win\_find\_activate**

#win\_find\_activate caption\_id

Ищет первое окно в заголовке которого есть id и делает его активным

в переменной \[win\_find\_activate\] возвращает hwnd окна или 0, если не найдено.

**#win\_find**

#win\_find caption\_id

Ищет первое окно в заголовке которого есть id

в переменной \[win\_find\] возвращает hwnd окна или 0, если не найдено.

**#win\_setpos**

#win\_setpos wnd,left,top,width,height

задает положение окна, нужно передать wnd полученный например через #win\_find

**#win\_setpos**

#win\_setpos wnd,left,top,width,height

задает положение окна, нужно передать wnd полученный например через #win\_find

  

  

#### 22.Ximage для работы с изображениями

**#ximage\_convert\_picture**

#ximage\_convert\_picture file\_name,new\_file\_name,width,height,dst\_format={bmp,gif,jpg(def),png,ico,tif,tga..}',origin\_x,origin\_y,origin\_width,origin\_height,transform=\[FLIP MIRROR NEGATIVE RLEFT RRIGHT R180 GRAY\]

Читает картинку из файла, конвертирует по переданным размерам и сохраняет в выходной файл

**#ximage\_get\_picture\_dim**

получает размеры картинки из файла

**#ximage\_get\_picture\_dim file\_name**

задает переменные

\[ximage.width\]

\[ximage.height\]

\[ximage.size\]

**#ximage\_clipboard\_to\_file**

сохраняет картинку из буфера обмена в файл, задает при необходимости размеры

#ximage\_clipboard\_to\_file file\_name,width={0=default},height={0=default},dst\_format={bmp,gif,jpg(def),png,ico,tif,tga..}

**#ximage\_load\_bits2hex**

загрузка файла картинки в строковую переменную с преобразованием в HEX

[#ximage\_load\_bits2hex](about:blank) file\_name,dst\_var\_name,dst\_format={HEX,HEX\_FULL},byte\_delim\_char(ansicode),row\_delim\_char(ansicode),inversion,bit\_reverse,null\_bit,transform=\[FLIP MIRROR NEGATIVE RLEFT RRIGHT R180 GRAY\]'

# Регламент по описанию выполненных работ

Введение:

Данный регламент устанавливает обязательные стандарты документирования для всех разработчиков, участвующих в процессе создания программного обеспечения. Цель - обеспечить четкость, прозрачность и воспроизводимость всех внесенных изменений в код.

1\. Обязательное Документирование:

1.1 Каждое внесенное изменение в исходный код программы обязательно должно быть задокументировано.

1.2 Документирование включает в себя краткое описание изменения, его цель, а также подробные пошаговые инструкции или комментарии к коду, объясняющие, как и почему изменение было внесено.

1.3 Изменения должны быть документированы непосредственно в исходном коде в виде комментариев, а также в специальных отчетах или журналах изменений.

2\. Структура Документации:

2.1 Документация должна быть структурирована таким образом, чтобы любой разработчик, ознакомившийся с ней, мог легко понять, что было изменено и как это повлияет на систему в целом.

2.2 Каждый документированный элемент изменения должен содержать:

*   Описание изменения.
*   Дата внесения изменения.
*   Автор изменения.
*   Список всех файлов и функций, затронутых изменением.

2.3 Ниже приведены примеры составления документации в случаях выполнения конкретных задач

**Задача: Разработка нового инструмента**

Описание изменения: Добавлена команда #form\_get\_name, которая позволяет получить имя текущей формы, открытого отчета, и сохранить его в переменную form\_name.

Дата внесения изменения: \[Указать дату внесения изменения\]

Автор изменения: \[Указать имя автора, который добавил эту функциональность\]

Список всех файлов и функций, затронутых изменением:

1.     main\_script - Добавлен новый блок кода для команды #form\_get\_name. Внесены изменения в функцию get\_form\_name, которая теперь отвечает за извлечение имени текущей формы.

2.     utils - Добавлен новый вспомогательный метод для обработки полученного имени формы.

3.     report\_generator - Внесены изменения для использования полученного имени формы при генерации отчета.

  

**Задача: Доработка созданного ранее инструмента, и добавление нового функционала**

Описание изменения: Добавление нового функционала к ранее созданному инструменту.

Дата внесения изменения: \[Указать дату внесения изменения, например, "25 октября 2023 г."\]

Автор изменения: \[Указать имя программиста, внесшего изменения\]

Список всех файлов и функций, затронутых изменением:

1.     existing\_tool.py - Внесены изменения в существующий инструмент.

2.     new\_feature.py - Добавлен новый файл с кодом новой функциональности.

3.     [utils](http://utils.py) - Внесены изменения в утилитарные функции для поддержки нового функционала.

4.    [README](http://README.md) - Обновлен файл с описанием инструмента, включая новую функциональность.

Функциональные изменения:

*   Добавлена новая функция new\_feature() в файле new\_feature.py, которая предоставляет возможность выполнения новых задач.
*   В файле existing\_tool.py были внесены изменения для интеграции новой функциональности.
*   В файле [utils](http://utils.py) были внесены изменения для поддержки новой функциональности.
*   В файле [README](http://README.md) была добавлена информация о том, как использовать новую функциональность.

Данные изменения позволяют расширить возможности инструмента и предоставить пользователям новые функции для выполнения задач.

**\***

**Задача: осуществление тех поддержки пользователя по созданному ранее продукту**

Для описания добавленного функционала программистом в рамках технической поддержки пользователя созданного ранее продукта, вы можете использовать следующий формат:

1.Описание изменения:

oЗдесь необходимо кратко описать суть внесенного изменения. Например, "Добавлена функция для сброса пароля пользователя через электронную почту."

2.Дата внесения изменения:

oУкажите точную дату, когда изменение было внесено. Например, "25 октября 2023 года."

3.Автор изменения:

oУкажите имя или идентификацию программиста, который внес данное изменение. Например, "Иван Петрович."

4.Список всех файлов и функций, затронутых изменением:

oПеречислите файлы и функции, в которых были внесены изменения. Это может включать как новые файлы и функции, так и изменения в существующих. Например:

oФайлы:

§user\_manager

§email\_utils

oФункци

§reset\_password(user\_id)

§     send\_password\_reset\_email(user\_email)

Этот формат поможет вести документацию о внесенных изменениях, что полезно для команды разработки и поддержки, чтобы легче отслеживать и понимать, что было сделано в рамках технической поддержки.

Описание изменения: Добавление новой функциональности для улучшения безопасности продукта.

Дата внесения изменения: 2023-10-20

Автор изменения: Иван Петров, программист по администрированию.

Список всех файлов и функций, затронутых изменением:

1.     [security](http://security.py) - Добавлена новая функция validate\_user\_credentials(), которая осуществляет дополнительную проверку учетных данных пользователей при входе в систему.

2.     user\_management - Изменена функция change\_password(), чтобы учесть новые правила для паролей пользователей, усиливая безопасность.

3.     [logging](http://logging.py) - Добавлен новый логгер для регистрации всех попыток неудачных входов в систему с подробной информацией о попытках.

4.     [database](http://database.py) - Внесены изменения в запросы к базе данных для учета дополнительной информации о пользователях.

5.     [settings](http://settings.py) - Обновлены конфигурационные параметры, чтобы учитывать новые настройки безопасности, такие как минимальная длина пароля и требования к паролю.

6.     email\_notifications.py - Добавлена функция notify\_admin\_on\_security\_event(), которая отправляет уведомления администратору при обнаружении несанкционированных действий в системе.

7.     admin\_dashboard.html - Изменен интерфейс администраторской панели для отображения новых метрик безопасности и оповещений.

Эти изменения были внесены для повышения безопасности продукта и обеспечения надежной защиты данных пользователей.

Задача: Настройка и администрирование созданного ранее продукта

Описание изменения: Добавление новой функциональности для улучшения безопасности продукта.

Дата внесения изменения: 2023-10-20

Автор изменения: Иван Петров, программист по администрированию.

Список всех файлов и функций, затронутых изменением:

1.     [security](http://security.py)

\- Добавлена новая функция validate\_user\_credentials(), которая осуществляет

дополнительную проверку учетных данных пользователей при входе в систему.

2.     user\_management.py - Изменена функция change\_password(), чтобы учесть новые правила для паролей пользователей, усиливая безопасность.

3.     [logging](http://logging.py)

\- Добавлен новый логгер для регистрации всех попыток неудачных входов в систему

с подробной информацией о попытках.

4.     [database](http://database.py)

\- Внесены изменения в запросы к базе данных для учета дополнительной информации

о пользователях.

5.     [settings](http://settings.py)

\- Обновлены конфигурационные параметры, чтобы учитывать новые настройки

безопасности, такие как минимальная длина пароля и требования к паролю.

6.     email\_notifications - Добавлена функция notify\_admin\_on\_security\_event(), которая отправляет уведомления администратору при обнаружении несанкционированных действий в системе.

7.     admin\_dashboard - Изменен интерфейс администраторской панели для отображения новых метрик безопасности и оповещений.

Эти изменения были внесены для повышения безопасности продукта и обеспечения надежной защиты данных пользователей.

3\. Обновление Документации:

3.1 Документация должна обновляться непосредственно в момент внесения изменений в код.

3.2 Если изменения касаются существующей функциональности, соответствующие разделы документации также должны быть обновлены, чтобы отразить новые возможности или изменения в поведении программы.

4\. Проверка и Утверждение Документации:

4.1 Перед тем как изменения будут включены в основной код, документация должна быть рассмотрена и утверждена соответствующими техническими экспертами или руководителями проекта.

4.2 Утвержденная документация должна быть частью основной документации проекта и поддерживаться в актуальном состоянии.

Заключение:

Соблюдение данного регламента по документированию изменений в программном обеспечении является обязательным для всех разработчиков. Четкость и подробность документации помогут улучшить взаимодействие и облегчить дальнейшую работу других разработчиков

# Описание другого шаблонизатора, которое можно взять на пример нашему

За пример взял шаблонизатор "Mustache"

**Mustache** - это минималистичный шаблонный язык разметки, который используется для генерации динамических текстовых шаблонов. Mustache не является языком программирования, а, скорее, инструментом для заполнения шаблонов данными. Вот подробное описание особенностей Mustache:

1. **Простота и минимализм:** Mustache разрабатывался с акцентом на минимализме и простоте использования. Язык предоставляет всего несколько базовых конструкций для вставки данных в шаблоны.
2. **Синтаксис:** Основной синтаксис Mustache включает двойные фигурные скобки `{{ }}`, в которые помещаются переменные, которые вы хотите вставить в шаблон. Например, `{{ name }}` будет заменено на значение переменной `name`.
3. **Избегание логики:** Mustache следует принципу "отсутствия логики" и предназначен для простой вставки данных в шаблоны, а не для выполнения сложных операций или условных выражений. Это способствует разделению логики и представления.
4. **Условные выражения:** Mustache поддерживает условные выражения с использованием секций. Например, `{{#is_active}}Активен{{/is_active}}` будет отображено только в том случае, если переменная `is_active` равна `true`.
5. **Итерации:** Язык также поддерживает итерации через списки данных. Вы можете использовать секции для отображения списка элементов.
6. **Чистота:** Одной из главных черт Mustache является чистота и безопасность. Это означает, что вставляемые данные автоматически экранируются, чтобы предотвратить внедрение вредоносного кода (XSS-атаки).
7. **Множественные реализации:** Mustache доступен на многих платформах и в различных языках программирования, что делает его портируемым и универсальным инструментом.
8. **Популярность:** Mustache широко используется во множестве языков программирования и сред разработки, что делает его популярным выбором для создания шаблонов веб-страниц, отправки электронных писем, генерации кода и других задач.

# Документация по добавлению списка кода ошибок

Документация для разработчика

**Введение**

Документация для разработчика предоставляет информацию о том, как добавить список кодов ошибок и реализовать упрощенную навигацию по ним в программе. Это позволит пользователям более эффективно управлять ошибками, возникающими в процессе использования программы.

**Шаг 1: Создание списка кодов ошибок**

Для начала, нужно создать список кодов ошибок. Коды ошибок могут быть числовыми или текстовыми идентификаторами, которые уникально идентифицируют каждую ошибку. Например:

1 - Ошибка входа в систему

2 - Неверный формат файла

3 - Сетевая ошибка

4 - Недостаточно прав доступа

Создайте структуру данных, где каждый код ошибки связан с описанием и, при необходимости, дополнительной информацией о том, как решить проблему.

**Шаг 2: Интеграция списка кодов ошибок**

Добавьте созданный список кодов ошибок в код вашей программы. Можно воспользоваться структурами данных, чтобы хранить коды ошибок и связанную с ними информацию.

**Шаг 3: Реализация упрощенной навигации по ошибкам**

Чтобы обеспечить пользователям удобный доступ к информации о кодах ошибок, вы можете реализовать упрощенную навигацию. Например, при возникновении ошибки, вы можете предоставить пользователю код ошибки и краткое описание, а также ссылку или кнопку для получения дополнительных сведений.

Вот пример того, как может выглядеть такая навигация:

1. При возникновении ошибки в программе, отобразите код ошибки и краткое описание на экране для пользователя.
2. Добавьте ссылку "Подробнее" или кнопку "Информация об ошибке" рядом с кодом ошибки.
3. По нажатию на ссылку или кнопку, пользователь может получить дополнительную информацию о коде ошибки, включая возможные способы устранения проблемы.

**Заключение**

Добавление списка кодов ошибок и упрощенной навигации по ним в вашей программе поможет пользователям более эффективно решать проблемы, с которыми они могут столкнуться. Это улучшит пользовательский опыт и уменьшит количество обращений в службу поддержки.

# 1212121

12121212121 тест экспорта маркдовн с картинкой

![](https://t4595086.p.clickup-attachments.com/t4595086/e86f25f9-6339-4db7-a91d-ba16946bf977/image.png)